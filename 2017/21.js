const initial = `
.#.
..#
###
`
  .split(/\n/)
  .slice(1, -1)

const fliph = ([...matrix]) => matrix.reverse()
const flipv = matrix => matrix.map(([...x]) => x.reverse()).map(x => x.join(''))
const rotate = matrix =>
  matrix.reduce(
    (sum, row, i) => [...sum, ...[matrix.map(x => x[i]).join('')]],
    []
  )

function * split (matrix) {
  const length = matrix[0].length
  const size = length % 2 === 0 ? 2 : 3
  const sizes = [...Array(size).keys()]
  const row = new RegExp('.'.repeat(size), 'g')
  for (let i = 0; i < length; i += size) {
    const rows = sizes.map(j => matrix[i + j].match(row))
    for (let j = 0; j < length / size; j++) {
      yield sizes.map(k => rows[k][j])
    }
  }
}

function stitch (matrices) {
  const threshold = Math.sqrt(matrices.length)
  const size = matrices.length
  const matrix = []

  for (let i = 0; i < size; i += threshold) {
    for (let j = 0; j < matrices[0].length; j++) {
      const row = matrices
        .slice(i, threshold + i)
        .map(x => x[j])
        .join('')
      matrix.push(row)
    }
  }
  return matrix
}

function matchRule (matrix, rule) {
  matchRule.cache = matchRule.cache || {}
  const match = a => {
    const ok = a.toString() === rule.toString()
    matchRule.cache[[matrix, rule]] = ok
    return ok
  }

  if (typeof matchRule.cache[[matrix, rule]] !== 'undefined') {
    return matchRule.cache[[matrix, rule]]
  }
  if (match(matrix)) return true
  if (match(flipv(matrix))) return true
  if (match(rotate(flipv(matrix)))) return true
  if (match(rotate(flipv(fliph(matrix))))) return true
  if (match(fliph(matrix))) return true
  if (match(rotate(fliph(matrix)))) return true
}

const rules = `
../.. => .##/##./.#.
#./.. => .#./#.#/##.
##/.. => #.#/#.#/###
.#/#. => #../.#./.#.
##/#. => ##./#.#/..#
##/## => #.#/#.#/...
.../.../... => ..##/##../##../#.#.
#../.../... => ##.#/..#./#.#./.#..
.#./.../... => ..#./##.#/#.##/###.
##./.../... => ###./##.#/.###/#.#.
#.#/.../... => ##../#..#/.###/#.#.
###/.../... => ...#/#..#/...#/...#
.#./#../... => ...#/.##./#.##/..#.
##./#../... => .##./.#../.##./.#..
..#/#../... => ####/.#../#.#./.###
#.#/#../... => ###./.#../##../....
.##/#../... => ##../#.#./#.#./##..
###/#../... => #.##/#..#/.#../##..
.../.#./... => .#.#/.###/.##./##..
#../.#./... => .###/.##./..##/..##
.#./.#./... => .##./.#.#/#.##/.###
##./.#./... => ..#./..../..#./###.
#.#/.#./... => ..../..#./..##/##..
###/.#./... => .#.#/#..#/.###/#..#
.#./##./... => ..../..#./.#../####
##./##./... => ..##/#.##/..#./#.##
..#/##./... => ..../#.##/.##./####
#.#/##./... => ..##/#.#./.#../.##.
.##/##./... => #.../...#/###./....
###/##./... => .#../#.#./#.##/....
.../#.#/... => #.#./####/#.../..#.
#../#.#/... => ...#/.#.#/###./.#.#
.#./#.#/... => #..#/#.../###./#.##
##./#.#/... => .##./#.../...#/#.##
#.#/#.#/... => #..#/##../##../.#..
###/#.#/... => #.#./...#/.#.#/.##.
.../###/... => .#.#/.##./..#./.#..
#../###/... => .###/..##/#.##/.#..
.#./###/... => #.../#.../.#../#...
##./###/... => .###/...#/.#.#/.#..
#.#/###/... => .#../..##/#..#/#...
###/###/... => .###/##../##.#/#.#.
..#/.../#.. => ##.#/..../...#/..##
#.#/.../#.. => .#.#/###./...#/.#.#
.##/.../#.. => ##.#/.#../####/#.##
###/.../#.. => #.../#..#/###./....
.##/#../#.. => #..#/..#./####/...#
###/#../#.. => ####/###./##.#/....
..#/.#./#.. => .##./.##./##../#..#
#.#/.#./#.. => #..#/#..#/#.../.#..
.##/.#./#.. => ##../##.#/#.##/..##
###/.#./#.. => #.##/..##/.##./#.#.
.##/##./#.. => #.##/..../##../....
###/##./#.. => ###./.#.#/.###/.#..
#../..#/#.. => .###/#.##/..#./.##.
.#./..#/#.. => #..#/..##/.#.#/##..
##./..#/#.. => ###./#.../..##/##..
#.#/..#/#.. => #.../.##./.###/###.
.##/..#/#.. => ...#/##.#/..#./...#
###/..#/#.. => ###./..#./.#../...#
#../#.#/#.. => #..#/...#/..#./.#.#
.#./#.#/#.. => #..#/##.#/####/.##.
##./#.#/#.. => .###/##../..../.#..
..#/#.#/#.. => ..#./##.#/####/###.
#.#/#.#/#.. => #.#./#.##/##.#/.###
.##/#.#/#.. => ..#./####/##../.###
###/#.#/#.. => .#.#/###./.#.#/#...
#../.##/#.. => .###/..##/.#.#/..#.
.#./.##/#.. => #.##/.#../.###/#.#.
##./.##/#.. => .###/#.../#.../..#.
#.#/.##/#.. => ##../...#/..#./...#
.##/.##/#.. => ..##/.#.#/...#/####
###/.##/#.. => ##../.###/##../###.
#../###/#.. => ###./#..#/#.#./....
.#./###/#.. => ..../#.#./.###/.###
##./###/#.. => .###/##../#..#/####
..#/###/#.. => ..../#.#./#..#/##..
#.#/###/#.. => .#.#/..##/##.#/#..#
.##/###/#.. => .#../...#/##../.#..
###/###/#.. => #.../.###/###./##.#
.#./#.#/.#. => .#.#/#.##/###./#...
##./#.#/.#. => .#../.#../.#../.#..
#.#/#.#/.#. => ##.#/..../###./.#..
###/#.#/.#. => #.#./##.#/.#.#/##..
.#./###/.#. => ##.#/..#./..#./#.#.
##./###/.#. => ####/.###/.#.#/.##.
#.#/###/.#. => .#../.###/##../#.#.
###/###/.#. => #.../.##./..##/####
#.#/..#/##. => ..../..#./##../...#
###/..#/##. => .###/..#./#.##/###.
.##/#.#/##. => .###/..../#.#./...#
###/#.#/##. => ###./...#/.###/####
#.#/.##/##. => #.##/#.../..../...#
###/.##/##. => #.../#.../#..#/...#
.##/###/##. => .#../###./.###/..#.
###/###/##. => ##.#/.#../###./.#..
#.#/.../#.# => #.#./#.#./..../...#
###/.../#.# => ####/###./..../##.#
###/#../#.# => .###/##.#/#.##/..#.
#.#/.#./#.# => ###./.###/#.##/....
###/.#./#.# => .##./###./#.#./##..
###/##./#.# => #.../.#.#/#.##/#..#
#.#/#.#/#.# => ..#./#.#./##../..##
###/#.#/#.# => ..#./.#../...#/.##.
#.#/###/#.# => ..#./###./##.#/####
###/###/#.# => #.../#.#./#..#/.#.#
###/#.#/### => ..##/.##./.#.#/#...
###/###/### => .##./..##/####/###.
`
  .split(/\n/)
  .slice(1, -1)
  .map(line => {
    const split = line.split(/ => /)
    const re = /\//
    return split.map(x => x.split(re))
  })

let matrix = initial

for (let i = 0; i < 5; i++) {
  matrix = stitch([...split(matrix)]
    .map(x => rules.find(rule => matchRule(x, rule[0]))[1])
  )
}

console.log('part1 answer', matrix.reduce((sum, row) => sum + [...row].filter(x => x === '#').length, 0))

matrix = initial

for (let i = 0; i < 18; i++) {
  matrix = stitch([...split(matrix)]
    .map(x => rules.find(rule => matchRule(x, rule[0]))[1])
  )
}

console.log('part2 answer', matrix.reduce((sum, row) => sum + [...row].filter(x => x === '#').length, 0))
